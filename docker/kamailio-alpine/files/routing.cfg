
# the return code of a function as follow:
# <0 (negative value) - it is evaluated to false
# >0 (positive value) - it is evaluated to true
# =0 (zero) - it is evaluated as exit (stop execution of configuration file) 
# However, if return code is 0, the next action after function() is not executed. It can be used only of positive or negative response code.

####### Routing Logic ########

/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

#!ifdef WITH_EXEC
	exec_msg("/etc/kamailio/execshow.sh >>/tmp/aw123.out");
#!endif

#!ifdef WITH_DEBUG
	# debug info
	xlog("L_INFO","=UNFILTERED=>: $rm ($fu ($si:$sp) to $tu, $ci)\n");
#!endif

#!ifdef WITH_DMQ
    # handle DMQ messages
	if ($rm == "KDMQ" && $rp == DMQ_PORT) {
        dmq_handle_message();
        exit;
    }
#!endif

#!ifdef TLS_ONLY
	# only accept TLS connections
	if(proto != TLS) {
		xlog("L_INFO", "rejecting non TLS (encrypted) $ru from $si\n");
		sl_send_reply("403", "Accepting TLS Only");
		exit;
	}
#!endif

	# initial tests
	route(FIRST);
	route(INFO);

	# per request initial checks
	route(REQINIT);

	# emergency routing
	route(EHANDLING);
	
#!ifdef WITH_SPEEDDIAL
	# search for short dialing - * plus 4-digit extension
	if (uri==myself) {
		if(uri=~"sip:[2,5-9][0-9][0-9]@.*")
			xlog("L_ERROR", "Doing speeddial lookup for $rU\n");
			sd_lookup("speed_dial");
	}
#!endif

	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
#!ifdef WITH_NAT
		rtpengine_manage();
		handle_ruri_alias();
#!endif
		if (!t_relay_cancel()) {
			xlog("L_ERROR", "No matching transaction or other error on CANCEL\n");
			sl_send_reply("500", "Internal Server Error");
		}
		exit;
	}
	
	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	### authentication
	if (is_method("REGISTER")) {
		remove_hf("Route");
		route(REGISTRAR); # needs to register (location) first
	}
    route(AUTH);

	if ($rU==$null) {
		# request with no Username in RURI
		xlog("L_INFO", "Rejecting, request with no Username in RURI\n");
		sl_send_reply("484","Address Incomplete");
		exit;
	}

#!ifdef WITH_NAT
	if (has_body("application/sdp")) {
    	rtpengine_manage();
   	}
#!endif

	# record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
	add_path();

#!ifdef WITH_SBC
	if (is_method("INVITE|SUBSCRIBE")) {
		switch ($proto) {
			case "TLS":
				record_route_preset("EXTERNAL_NAME:SIPS_PORT;transport=tls", "EXTERNAL_IP:5061");
				break;
			case "TCP":
				record_route_preset("EXTERNAL_NAME:SIP_PORT;transport=tcp", "EXTERNAL_IP:5060");
				break;
			case "UDP":
				record_route_preset("EXTERNAL_NAME:SIP_PORT;transport=udp", "EXTERNAL_IP:5060");
				break;
		}
	}
#!endif

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

#!ifdef WITH_PABX
    #### PABX (private) internal routing
    xlog("L_ERROR","Internal (PABX) Processing.....");
	route(PABX);
#!endif

#!ifdef WITH_MICROSOFT_TEAMS
    #### Microsoft Teams routing
	### xlog("L_ERROR","Microsoft Teams Processing.....");
	### route(TEAMS);
#!endif
	
#!ifdef WITH_TRUNK
	#### Public / PSTN / routing
	xlog("L_ERROR","Trunk Processing.....");
	route(TRUNK);
#!endif

	#### catch - should never get here
	xlog("L_ERROR","Can't deal with number $rU from $si:$sp - sending error");
	sl_send_reply("501","Fuck off");
    exit;
}

route[FIRST] {
    #### Check for shutdown mode:
    if ($sel(cfg_get.system.shutdownmode) > 0) {
		xlog("L_WARN", "Shuting down so ignoring $si\n");
        send_reply("503", "Server shutting down");
        exit;
   	}

    if (is_method("INVITE|REGISTER")) {
        ##### scanner - IP address in UA
        if($sel(contact.uri.host) =~ "^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$") {
            route(BLOCKIP);
			xlog("L_INFO","$si is using IP addressess instead of DNS - ignoring");
			exit;
        }
        ##### SQL Injection
        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
            xlog("L_INFO","$si:$sp is trying to do a sql injection attack with $au - ignoring");
			route(BLOCKIP);
		    exit;
        }
        ##### Spoofing Attack
        ##if($(hdr(Record-Route)[0]{nameaddr.uri}) != $si and $(hdr(Record-Route)[0]{nameaddr.uri}) != $null) {
        ##    xlog("L_INFO","Spoofing attack detected from $si with $ru - ignoring");
		##    route(BLOCKIP);
		##    exit;
        ##}
    }
	##### check if known SIP scanner
	if($ua =~ "(Cisco-SIPGateway|Intraswitch|friendly-scanner|sipvicious|sipcli|sip-scan|sipsak|sundayddr|iWar|CSipSimple|SIVuS|Gulp|sipv|smap|friendly-request|VaxIPUserAgent|siparmyknife|Test Agent)") {
#!ifdef DEBUG
		xlog("L_ERROR","Known SIP Scanner [$ua] trying to call $rU - ignoring");
#!endif
		route(BLOCKIP);
		# optional send Ok - can make the scammers stop sooner
		sl_send_reply("200", "OK");
        exit;
    }
    
	#### check if known User Agent - ignore otherwise but allow null
	if !($ua =~ "(3CX|baresip|Linphone|Bria iOS|Microsoft.PSTNHub)" || $ua==$null) {
#!ifdef DEBUG
        # xlog("L_ERROR","Unknown User Agent [$ua] trying to call $rU - ignoring\n");
#!endif
		# optional send Ok - can make the scammers stop sooner
		sl_send_reply("200", "OK");
        exit;
    }
    
	#### too many hops
	if(!mf_process_maxfwd_header("10")) {
		xlog("L_ERROR","Too many hops from $si:$sp - sending error\n");
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	#### SIP message too big
	if(msg:len>2048) {
    	xlog("L_ERROR","SIP Message too big from $si:$sp - sending error\n");
	    sl_send_reply("413", "Message too large");
        exit;
    };

	#### Phone number too long
	if($(rU{s.len}) > 15 ) {
		xlog("L_ERROR", "Phone number is too long from $si:$sp with $rU - sending error");
		sl_send_reply("413","Not Accepted");
		exit;
	}
	
	#### process keep alives - but only ones sent to here
	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		xlog("L_INFO","Sending Keepalive to [$ua] via $sp from $si:$sp\n");
		sl_send_reply("200","Keepalive");
		exit;
	}

	#### malformed SIP messages
	if(!sanity_check("1511", "7")) {
		xlog("L_ERROR","Malformed SIP message from $si:$sp - ignoring\n");
		# quietly ignore
		drop;
	}
	return;
}

route[INFO] {
#!ifdef WITH_GEOIP
    if(geoip2_match("$si", "src")) {
 		##xlog("L_INFO","Packet recieved from IP $si");
		##xlog("L_INFO","Country is: $gip2(src=>cc)\n");
		##xlog("L_INFO","City is: $gip2(src=>city)");
		##xlog("L_INFO","ZIP is: $gip2(src=>zip)");
		##xlog("L_INFO","Regc is: $gip2(src=>regc)");
		##xlog("L_INFO","Regn is: $gip2(src=>regn)");
		##xlog("L_INFO","Metro Code is: $gip2(src=>metro)");
        if($gip2(src=>cc)=="") {
            xlog("L_INFO","Cannot determine geoip ip for [$si] - ignoring");
            exit;
        }
        ## Microsoft sip[1|2].pstnhub.microsoft.com are located in
        ## Singapore (SG), USA (US) and Netherlands (NL)
	    if($gip2(src=>cc)=~"AU|US|NL|SG"){
            ## Pretty format
            ## xlog("L_INFO","processing: $gip2(src=>cc):$pr:$si:$sp[$rm]($fu) [$ua]\n");
			## xlog("L_INFO","Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci] [$ua]\n");
#!ifdef WITH_DEBUG
			xlog("L_INFO","=FILTERED=>: $rm ($fu ($si:$sp) to $tu, $ci)\n");
#!else
			;
#!endif
			## xnotice("[$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci]\n");
        } else {
            xlog("L_INFO","Traffic [$si] is not from AU/US/NL/SG, its from $gip2(src=>cc) so - ignoring");
            exit;
        }
    }
#!endif
	return;
}

# Per SIP request initial checks
route[REQINIT] {
	# no connect for sending replies
	set_reply_no_connect();
	# enforce symmetric signaling
	# - send back replies to the source address of request
	force_rport();

#!ifdef WITH_ANTIFLOODING
#!ifdef WITH_APIBAN
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from apiban.org blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif
#!endif
	return;
}

route[APIBAN] {
#!ifdef WITH_APIBAN
	// check if we already have an APIBAN id... if so, get the updates and
	// if not, get the full list of banned ips.

	// replace MYAPIKEY with your apiban.org API key.
	$var(apikey) = "APIBANKEY";

	if($sht(apibanctl=>ID) == 0) {
		$var(apiget) = "https://apiban.org/api/" + $var(apikey) + "/banned";
	} else {
		$var(apiget) = "https://apiban.org/api/" + $var(apikey) + "/banned/" + $sht(apibanctl=>ID);
	}

	xlog("L_INFO","APIBAN: Sending API request to $var(apiget)\n");
	http_client_query("$var(apiget)", "$var(banned)");

	// if we dont get a 200 OK from the webserver we will log and exit
	if($rc!=200) {
		xlog("L_INFO","APIBAN: No 200 Received. $var(banned)\n");
		exit;
	}

	// lets loop through the ipaddresses we received from our API request
	$var(count) = 0;
	jansson_array_size("ipaddress", $var(banned), "$var(size)");
	while($var(count) < $var(size)) {
		jansson_get("ipaddress[$var(count)]", $var(banned), "$var(blockaddr)");
		// add the blocked ipaddress to the apiban htable and log
		$sht(apiban=>$var(blockaddr)) = 1;
		xlog("L_INFO","API: ipaddress[$var(count)] == $var(blockaddr)\n");

		$var(count) = $var(count) + 1;
	}

	// lets get our control ID and use it for incremental downloads
	jansson_get("ID", $var(banned), "$var(apiid)");
	xlog("L_INFO","ID: $var(apiid)\n");
	$sht(apibanctl=>ID) = $var(apiid);
#!endif
	return ;
}

#!ifdef WITH_APIBAN
event_route[htable:mod-init] {
	# pre load apiban
	route(APIBAN);
}
#!endif

# Create Contact Record
route[CONTACT] {
	if ($(ct{tobody.user})!=$null) {
		$var(ctuser) = $(ct{tobody.user});
		$var(cthost) = $si;
		$var(ctport) = $sp;
		xlog("L_INFO","Adding Contact $var(ctuser):$var(cthost):$var(ctport)");
		#remove_hf("Contact");
		#insert_hf("Contact: <sip:$var(ctuser)@EXTERNAL_NAME:$var(ctport)\r\n");
	}
}

######################################################################
# Notify someone that a emergency number has been dialed - via uac
######################################################################
route[ENOTIFY] {
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
	$uac_req(ruri)="sip:TRUNK_HOSTP:TRUNK_PORT";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Emergency Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
    $uac_req(evroute)=1;
	
	// Permit authentication
	t_on_failure("MANAGE_FAILURE");

    // Send UAC Request
	xlog("L_INFO", "Sending $uac_req(method) request to $uac_req(ruri)");
	uac_req_send();
	
    return ;
}

route[EHANDLING] {
	# Australian Emergency Numbers (Victoria)
	# 000 (Emergency), 112 (Emergency) , 132 500 (SES), 131 444 (Police Assistance)
	# 131 114 (Lifeline)

    if(is_method("INVITE") && ($rU == "000" or $tU == "112" or $tU == "999000")) {
        #Matches any INVITEs with the Request URI to Address as 000, 112 or 116
        xlog("L_CRITICAL","Emergency call from $fU to $rU (Emergency number) CSeq is $cs ");
        route(ENOTIFY);
		## if it s our test number, don't route, notify is enough
		if ($tU != "999000") {
			route(RELAY);
		}
		exit;
    }
    return ;
}

## Private Routing (Internal)
route[PABX] {
    # xlog("PABX Settings: PABX1_NUMBER, PABX2_NUMBER, EXTERNAL_NAME");
    if ($ru=~"PABX1_NUMBER|\b(2[0-9][0-9]{1})\b") {
        ## Albert Park Extension
        xlog("L_INFO","Routing call $tU to Albert Park");
        # ????
		$tU = "PABX1_NUMBER";
		$var(disgroup) = 22;
		route(DISPATCH);
		exit;
    };
    if ($ru=~"PABX2_NUMBER|\b(5[0-9][0-9]{1})\b") {
        ## Somers Camp Extension
        xlog("L_INFO","Routing call $tU to Somers");
        # ???
		## $ru= "PABX2_NUMBER";
		$var(disgroup) = 55;
		route(DISPATCH);
		exit;
    };
    xlog("L_INFO","Call to $tU cannot be an internal call");
    return ;
}

## MS Team Routing
route[TEAMS] {
#!ifdef WITH_MICROSOFT_TEAMS
    ## Send to VM: "sip:user@yourdomain.com;opaque=app:voicemail"
    xlog("L_INFO","Routing to Microsoft Teams");
	# add header, other you'll get forbidden - which needs to be in a very specific format
	# Syntax: Contact: <phone number>@<FQDN of the SBC>:<SBC Port>;<transporttype>
	# TODO: need to replace with variables
	route(CONTACT);
	# append_hf("Contact: <sip:$ru@sbc.lordsomerscamp.org.au:5061;transport=tls>\r\n");
    $var(disgroup) = 44;
	route(DISPATCH);
#!endif
	return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
	if (nat_uac_test("19")) {
		xlog("L_INFO","***NAT**** detected for $rm ($fu ($si:$sp) to $tu, $ci)");
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if(is_first_hop()) {
				set_contact_alias();
			}
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# Handle SIP registrations
route[REGISTRAR] {
	if (!is_method("REGISTER")) return;

	if(isflagset(FLT_NATS)) {
		setbflag(FLB_NATB);
#!ifdef WITH_NAT
		# do SIP NAT pinging
		setbflag(FLB_NATSIPPING);
#!endif
	}
	if (!save("location")) {
		sl_reply_error();
	}
	exit;
}

# IP authorization and user authentication
route[AUTH] {
#!ifdef WITH_AUTH
#!ifdef WITH_IPAUTH
	if((!is_method("REGISTER")) && allow_source_address()) {
		# source IP is not allowed
		return;
	}
#!endif
	if (is_method("REGISTER") || from_uri==myself) {
		# change 1 to 0 so extension / auth_name can be different
		# authenticate requests
		if (!auth_check("$fd", "subscriber", "0")) {
			xlog("L_INFO", "auth_check failed - challenging $au from $fd via $proto");
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			# so next inline won't see them
			consume_credentials();
	}
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}
    return;
#!else
	xlog("L_ERROR", "Authentication is not enabled so we are not doing anything for anyone!!!");
    sl_send_reply("403","Not relaying");
	exit;
#!endif
}

route[SIPOUT] {
    if (uri==myself) return ;
    append_hf("P-hint: outbound\r\n");
    route(RELAY);
    exit;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

	if(nat_uac_test("8")) {
		rtpengine_manage("replace-origin replace-session-connection");
	} else {
		rtpengine_manage("trust-address replace-origin replace-session-connection");
	}

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
	}

	if(isbflagset(FLB_NATB)) {
		# no connect message in a dialog involving NAT traversal
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}
# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;

	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("ACK") ) {
#!ifdef WITH_NAT
			# ACK is forwarded statelessly
			route(NATMANAGE);
#!else
			xlog("Placeholder");
#!endif
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		### route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			route(RELAY);
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}

#!ifdef WITH_TRUNK
route[TRUNK] {
	# trunk calls need to be in E.164 format (+country etc...)
	
	# use regex
	if (!($rU =~ "^\+[0-9]+$")) {
		xlog("L_ERROR", "TRUNK: $ru not an E164 number (regex), reject - $rm from $fu to $du (IP:$si:$sp)($ci)\n");
		sl_send_reply("484", "Not an E164 number");
		exit;
	}

	# from siputils
	if (!is_tel_number("$rU")) { 
		xlog("L_ERROR", "TRUNK: $rU is not a telepone number (siputils/is_tel_number), reject - $rm from $fu to $du (IP:$si:$sp)($ci)\n");
		sl_send_reply("484", "Not an E164 number");
		exit;
	}	
	
	# we only accept Australian numbers
	if (!($rU =~ "^\+61")) {
		xlog("L_ERROR", "TRUNK: $rU is not an Australian number, reject - $rm from $fu to $du (IP:$si:$sp)($ci)\n");
		sl_send_reply("484", "International calls ($$) are not allowed");
		exit;
	}

	# sorry no Australian premium services
	if (($rU =~ "^\+61190")) {
		xlog("L_ERROR", "TRUNK: $rU is a premium number, reject - $rm from $fu to $du (IP:$si:$sp)($ci)\n");
		sl_send_reply("484", "Premium calls ($$) are not allowed");
		exit;
	}

	#if (is_method("INVITE|BYE")) {
	#	$var(disgroup) = 99;
	#	route(DISPATCH);
	#	exit;
	#}

	if (is_method("INVITE|BYE")) {
		# check if US/AUS number format (no international) - 411 (US), 1223 (Aus) is directory assitance
        if($ru=~"[2-9][0-9]{9}|[0][2-478][0-9]{8}|411|1223") {
			remove_hf("Contact");
            append_hf("Contact: <sip:$rU@sbc.lordsomerscamp.org.au:5061;transport=$proto>\r\n");
			rewritehostport("TRUNK_HOSTP:TRUNK_PORT");
            xlog("I_INFO","=======> Sending call $rU [$ua] to the trunk $du via $proto");
			route(RELAY);
			###  $var(disgroup) = 99;
            ###  route(DISPATCH);
			exit;
		}
    }
}

######################################################################
# Send a messages (SMS) -  via uac module
######################################################################
route["SEND_MESSAGE"] {
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
    $uac_req(ruri)="sip:TRUNK_HOSTP:TRUNK_PORT";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Message Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    // $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
	$uac_req(body)="A Message";
    $uac_req(evroute)=1;

	// Permit authentication
	t_on_failure("MANAGE_FAILURE");

    // Send UAC Request
    xlog("L_INFO", "Sending $uac_req(method) request to $uac_req(ruri)");
	uac_req_send();

	return ;
}

event_route[uac:reply] {
    xlog("received UAC reply code is: $uac_req(evcode)\n");
}
#!endif 

#!ifdef WITH_DISPATCHER
route[DISPATCH] {
	# destination sorted by priority attribute value (serial forking ordered by priority).
	# ds_select_domain vs ds_select_dst 
	# ds_select_dst (updates $du) vs ds_domain_dst (updates $ru)
	# $du - reference to destination uri, $ru - reference to request's URI (address in the first line of a SIP request)
    if(!ds_select_domain($var(disgroup), "8")) {
        send_reply("404", "No destination");
        exit;
    }
    remove_hf("Contact");
    append_hf("Contact: <sip:sbc.lordsomerscamp.org.au:$rp;transport=$proto>\r\n");
	// xlog("L_ERROR", "Dispatcher going to <$ru> via <$du> with $dP \n");
	xlog("L_ERROR", "Dispatcher Request's URI is <$ru>, Destination URI is $du via $proto\n");
	
    route(RELAY);
    exit;
}

event_route[dispatcher:dst-up] {
    xlog("L_ERROR", "Dispatcher <$ru>/<$du> is UP\n");
}
event_route[dispatcher:dst-down] {
    xlog("L_ERROR", "Dispatcher <$ru>/<$du> is DOWN\n");
}
#!endif

# Wrapper for relaying requests
route[RELAY] {
#!ifdef WITH_NAT
	handle_ruri_alias();
	switch ($rc) {
        case -1:
            xlog("L_ERR", "NAT (ruri_alias) Failed to handle alias of R-URI $ru\n");
            send_reply("400", "Bad request");
            exit;
        case 1:
            xlog("L_INFO", "NAT (ruri_alias) Routing in-dialog $rm from $fu to $du\n");
            break;
        case 2:
            xlog("L_INFO", "NAT (ruri_alias) Routing in-dialog $rm from $fu to $ru\n");
            break;
         };
#!endif
	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	xlog("L_INFO", "Attempting relaying for $ru\n");
	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
#!ifdef WITH_NAT
	route(NATMANAGE);
#!endif
}

# Manage route failures with MS Teams and others
failure_route[MANAGE_FAILURE] {

    if (t_is_canceled()) exit;

    # info
    xlog("I_INFO","****RELAY FAILURE***** with $T(reply_reason)[$T(reply_code)]");

#!ifdef WITH_TRUNK
    # need to authenticate trunk TODO: check destination IP addresss
    if(t_check_status("401|407")) {
        xlog("L_INFO", "Trying to Authenticate to Trunk $ru with TRUNK_USER...");
        $avp(auser) = "TRUNK_USER";
        $avp(apass) = "TRUNK_PASSWORD";
        uac_auth();
        t_relay();
        exit;
    }
#!endif

#!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
#!endif

#!ifdef WITH_BLOCK401407
    # block call redirect based on 401, 407 replies.
    if (t_check_status("401|407")) {
        t_reply("404","Not found");
        exit;
    }
#!endif
	exit;
}

route[BLOCKIP] {
#!ifdef WITH_APIBAN
	if (src_ip!=myself) {
		xlog("L_INFO","[R-BLOCKIP:$ci]: blocking $rm from $fu (IP:$si:$sp)\n");
		$sht(ipban=>$si) = 1;
	}
#!endif
	return;
}

### on 

#!ifdef WITH_SIPDEBUG
onsend_route {
	xlog("L_INFO","[ONSEND_ROUTE] SIP DEBUG: \n$snd(buf)\n");
}
onreply_route {
    xlog("L_INFO","[ONREPLY_ROUTE] SIP DEBUG: \n$snd(buf)\n");
}
#!endif

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
	xdbg("incoming ROUTE reply\n");
#!ifdef WITH_NAT
	if(status=~"[25][0-9][0-9]") {
		route(NATMANAGE);
	}
#!endif
#!ifdef WITH_NAT
	if (has_body("application/sdp")) {
	    rtpengine_manage();
    }
#!endif
}

#!ifdef WITH_MICROSOFT_TEAMS
# stateful logic - thisw can be permanent - does no harm
event_route[tm:local-request] {
    if(is_method("OPTIONS") && $ru =~ "pstnhub.microsoft.com") {
		## Keepalive need Contact header for Microsoft Teams
		append_hf("Contact: <sip:sbc.lordsomerscamp.org.au:5061;transport=tls>\r\n");
    	xlog("L_INFO", "Responded to OPTIONS keepalive from Microsoft Teams\n");
    }
}
#!endif
