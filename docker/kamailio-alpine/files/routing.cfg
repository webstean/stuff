
##modparam("ctl", "mode", 0666) 

route[INFO] {
#!ifdef WITH_GEOIP
    if(geoip2_match("$si", "src")){
 		##xlog("L_INFO","Packet recieved from IP $si");
		##xlog("L_INFO","Country is: $gip2(src=>cc)\n");
		##xlog("L_INFO","City is:  $gip2(src=>city)");
		##xlog("L_INFO","ZIP is:  $gip2(src=>zip)");
		##xlog("L_INFO","Regc is:  $gip2(src=>regc)");
		##xlog("L_INFO","Regn is:  $gip2(src=>regn)");
		##xlog("L_INFO","Metro Code is:  $gip2(src=>metro)");
        if($gip2(src=>cc)==""){
            xlog("L_INFO","Cannot determine geoip ip for [$si] - ignoring");
            exit;
        }
        ## Microsoft sip[1|2].pstnhub.microsoft.com are located in
        ## Singapore (SG), USA (US) and Netherlands (NL)
	    if($gip2(src=>cc)=~"AU|US|NL|SG"){
            ## Pretty format
            ## xlog("L_INFO","processing: $gip2(src=>cc):$pr:$si:$sp[$rm]($fu) [$ua]\n");
			xlog("L_INFO","Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci] [$ua]\n");
			## xnotice("[$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci]\n");
        } else {
            xlog("L_INFO","Traffic [$si] is not from AU/US/NL/SG its from $gip2(src=>cc) - ignoring");
            exit;
        }
    }
#!endif
	return;
}

route[HOMER_SECURITY_CHECKS] {
#!ifdef WITH_HOMER_SECURITY_CHECKS
    if (is_method("INVITE|REGISTER")) {
        # scanner
        if($ua =~ "(friendly-scanner|sipvicious|sipcli|sip-scan|sipsak|sundayddr|iWar|CSipSimple|SIVuS|Gulp|sipv|smap|friendly-request|VaxIPUserAgent|VaxSIPUserAgent|siparmyknife|Test Agent)") {
            xlog("L_INFO","Know SIP Scanner tried to connect from $si, - ignoring");
            exit;
        }
        # IP address in UA
        if($sel(contact.uri.host) =~ "^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$") {
            xlog("L_INFO","Someone coming form $si using IP addressess instead of DNS - ignoring");
            exit;
        }
        # SQL Injection
        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
            xlog("L_INFO","Someone from $si is doing an sql injection attack, blocking!");
            exit;
        }
        # Spoofing Attack
        if($(hdr(Record-Route)[0]{nameaddr.uri}) != $si and $(hdr(Record-Route)[0]{nameaddr.uri}) != $null) {
            xlog("L_INFO","Spoofing attack detected from $si, blocking");
            exit;
        }
    }
#!endif
    return;
}

######################################################################
# Enum first, then whatever the PSTN gateway is
######################################################################
route[PSTN_HANDLING] {
#!ifdef WITH_ENUM
	# First, we translate "tel:"-URI's to SIP-URI's:
	# $ru:           tel:+(34)-999-888-777
	# $fu:           sip:test@foo.com
	# becomes $ru:   sip:+34999888777@foo.com;user=phone
	if (!tel2sip("$ru", "$fd", "$ru")) {
		xlog("L_WARN","Failed to convert $ru to a sip:-URI - M=$rm R=$ru F=$fu T=$tu IP=$si:$sp ID=$ci\n\n");
        return ;
	}
    if ($rU =~ "\+[0-9]+") {
        # Now let's check, if the number can be found in ENUM:
		if(!enum_query()) {
			# ENUM failed, send it to the PSTN-Gateway:
            return ;
        }
    }
#!endif
	return ;
}

route[EMERGECY_HANDLING] {
    if(is_method("INVITE") && ($rU == "000" or $tU == "112" or $tU == "116" or $tU == "888")){
        #Matches any INVITEs with the Request URI to Address as 000, 112 or 116
        xlog("L_CRITICAL","Emergency call from $fU to $rU (Emergency number) CSeq is $cs ");
        ### route("EMERGENCY_NOTIFY");
        #You obviously would want this to route to an emergency services destination...
        sl_reply("200", "ok");
        exit;
    }
    return ;
}

######################################################################
# Albert Park Routing - Extensions 2Xs
######################################################################
route[ALBERT] {
    return ;
}

######################################################################
# Somers Camp Routing - Extensions 3Xs
######################################################################
route[CAMP] {
    return ;
}


######################################################################
# Notify someone that a emergency number has been dialed
######################################################################
route["EMERGENCY_NOTIFY"] {
#!ifdef WITH_UAC
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
    $uac_req(ruri)="sip:10.0.1.5:5060";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Emergency Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
    $uac_req(evroute)=1;
    uac_req_send();
#!endif
    return ;
}

#!ifdef WITH_UAC
event_route[uac:reply] {
    xlog("received reply code is: $uac_req(evcode)\n");
}
#!endif

route["SOMERS_ROUTING"] {
#!ifdef WITH_IPAUTH
    # If ANY permiitted IP range then allow routing
    if (allow_routing()) {
#!endif
        t_relay();
#!ifdef WITH_IPAUTH
    };
#!endif
}

route["SOMERS_REGISTAR"] {
    if (!is_method("REGISTER")) return;
#!ifdef WITH_IPAUTH
	if (allow_register("register.allow", "register.deny")) {
#!endif
   	    if (!save("location")) {
		    sl_reply_error();
        }
        exit;
#!ifdef WITH_IPAUTH
    } else {
	    sl_send_reply("403", "Forbidden");
    };
#!endif
}

route[MICROSOFT_SBC] {
#!ifdef WITH_MICROSOFT_SBC
	if (is_method("INVITE|SUBSCRIBE")) {
		## record_route(); - default, to
        record_route_preset("sbc.lordsomerscamp.rg.au:5061;transport=tls", "20.190.118.9:5060");
	};
#!endif
    return ;
}

#!ifdef WITH_MICROSOFT_SBC
# stateful logic
event_route[tm:local-request] {
    if(is_method("OPTIONS") && $ru =~ "pstnhub.microsoft.com") {
    	append_hf("Contact: <sip:sbc.lordsomerscamp.org.au:5061;transport=tls>\r\n");
    	xlog("L_INFO", "Sent out tm request (keepalive) for Microsoft: $mb\n");
    }
}
#!endif

# IP authorization and user authentication
route[SOMERS_AUTH] {
#!ifdef WITH_AUTH
#!ifdef WITH_IPAUTH
	if((!is_method("REGISTER")) && allow_source_address()) {
		# source IP is not allowed
		return;
	}
#!endif
	if (is_method("REGISTER") || from_uri==myself) {
		# authenticate requests
		# change 1 to 0 so extension / auth_name can be different
        if (!auth_check("$fd", "subscriber", "0")) {
			xlog("L_ERROR", "Authenticated failed for $fd");
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();
	}
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}
    return;
#!else
	xlog("L_ERROR", "Authenticaiton is not enabled so we are not doing anything for anyone!!!");
    sl_send_reply("403","Not relaying");
	exit;
#!endif
}

## something wrong
route[SOMERS_PSTN] {
	# Only if the AVP 'gw_ip' is set and the request URI contains
	# only a number we consider sending this to the PSTN GW.
	# Only users from a local domain are permitted to make calls.
	# Additionally you might want to check the acl AVP to verify
	# that the user is allowed to make such expensives calls.
#	if ($f.did != "" && $gw_ip != "" &&
#		uri=~"sips?:\+?[0-9]{3,18}@.*") {
		# probably you need to convert the number in the request
		# URI according to the requirements of your gateway here
		# if an AVP 'asserted_id' is set we insert an RPID header
#		if ($asserted_id != "") {
#			xlset_attr("$rpidheader", "<sip:%$asserted_id@%@ruri.host>;screen=yes");
#			replace_attr_hf("Remote-Party-ID", "$rpidheader");
#		}
		# just replace the domain part of the RURI with the
		# value from the AVP and send it out
#		attr2uri("$gw_ip", "domain");
#		route(FORWARD);
#	}
    return ;
}

route[SOMERS_ENUM] {
	# First, we translate "tel:"-URI's to SIP-URI's:
	# $ru:           tel:+(34)-999-888-777
	# $fu:           sip:test@foo.com
	# becomes $ru:   sip:+34999888777@foo.com;user=phone
	if (!tel2sip("$ru", "$fd", "$ru"))
		xlog("L_WARN","Failed to convert $ru to a sip:-URI - M=$rm R=$ru F=$fu T=$tu IP=$si:$sp ID=$ci\n\n");

	if ($rU =~ "\+[0-9]+") {
		# Now let's check, if the number can be found in ENUM:
		if(!enum_query()) {
			# ENUM failed, send it to the PSTN-Gateway:
			xlog("L_WARN","ENUM Query failed - routing to PSTN\n");
			route(PSTN);
			break;
		};
	};
}

route[SOMERS_SIPOUT] {
    if (uri==myself) return ;
    append_hf("P-hint: outbound\r\n");
    route(RELAY);
    exit;
}

route[DEFAULT] {
## from default kamailio.cfg - with some updates
	# per request initial checks
	route(REQINIT);

	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

    # Handle Emergency Numbers
    route(EMERGECY_HANDLING);
    
#!ifdef WITH_SPEEDDIAL
	# Speed dial - two digits
	if (uri==myself) {
		if(uri=~"sip:[0-9]{2}@.*") {
			xlog("L_WARN","Doing a speed dial lookup with $rU\n");
			# this function will replace R-URI if found
			sd_lookup("speeddial");
		};
	};
#!endif
	
	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	# authentication
	route(SOMERS_AUTH);

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE")) {
		record_route();
	}

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

	# dispatch requests to foreign domains
	route(SIPOUT);

	### requests for my local domains

	# handle presence related requests
	route(PRESENCE);

	# handle registrations
	route(REGISTRAR);

	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

    # dispatch destinations to PSTN
	route(SOMERS_PSTN);

	# user location service
	route(LOCATION);
}

#!ifdef WITH_WEBSOCKETS
## initial dummy so xhttp loads
event_route[xhttp:request] {
	exit;
}
#!endif
