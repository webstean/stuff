# the return code of a function as follow:
# <0 (negative value) - it is evaluated to false
# >0 (positive value) - it is evaluated to true
# =0 (zero) - it is evaluated as exit (stop execution of configuration file) 
# However, if return code is 0, the next action after function() is not executed. It can be used only of positive or negative response code.

####### Routing Logic ########

/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

#!ifdef WITH_EXEC
	# run script
	exec_msg("/etc/kamailio/execshow.sh >>/tmp/aw123.out");
#!endif

#!ifdef WITH_DEBUG
	# debug info
	xlog("L_INFO","=UNFILTERED=>: $rm ($fu ($si:$sp) to $tu, $ci)\n");
#!endif

#!ifdef WITH_DMQ
    # handle DMQ messages
	if ($rm == "KDMQ" && $rp == DMQ_PORT) {
        dmq_handle_message();
        exit;
    }
#!endif

#!ifdef TLS_ONLY
	# in the future, we'll only accept TLS connections
	if(proto != TLS) {
		xlog("L_INFO", "rejecting non TLS (encrypted) $ru from $si\n");
		sl_send_reply("403", "Accepting TLS Only");
		exit;
	}
#!endif

	# initial tests
	route(FIRST);
	route(INFO);

	# per request initial checks
	route(REQINIT);

	# set source and destination flags
	route(FLAGS);

	# emergency routing
	route(EHANDLING);
	
#!ifdef WITH_SPEEDDIAL
	# search for short dialing - * plus 4-digit extension
	if (uri==myself) {
		if(uri=~"sip:[2,5-9][0-9][0-9]@.*")
			### xlog("L_ERROR", "Doing speeddial lookup for $rU\n");
			sd_lookup("speed_dial");
	}
#!endif

	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}
	
	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### authentication
    route(AUTH);

	# handle registrations
	route(REGISTRAR);
	
	if ($rU==$null) {
		# request with no Username in RURI
		xlog("L_INFO", "Rejecting, request with no Username in RURI\n");
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE")) {
		record_route();
	}

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}
	
#!ifdef WITH_MSTEAMS
	# record_route_preset("EXTERNAL_NAME:SIPS_PORT;transport=tls", "EXTERNAL_IP:SIPS_PORT");
	record_route_preset("EXTERNAL_NAME:SIPS_PORT;transport=tls");
	# force_send_socket(tls:EXTERNAL_IP:SIPS_PORT);
#!else
	record_route();
#!endif

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

#!ifdef WITH_PABX
    #### PABX (private) internal routing
    xlog("L_INFO","Processing [$tU] *INTERNAL*...");
	route(PABX);
#!endif

#!ifdef WITH_MSTEAMS
    #### Microsoft Teams routing
	### xlog("L_INFO","Processing [$tU] *TEAMS*...");
	### route(TEAMS);
#!endif
	
	if (route(E164) ) {
#!ifdef WITH_TRUNK
		#### Public / PSTN / routing
		xlog("L_INFO","Processing [$tU] *TRUNK*...");
		route(TRUNK);
#!else
		sl_send_reply("403", "Trunk calls currently not supported");
#!endif
	} else {
		route(SIPOUT);
	};

	# user location service
	## route(LOCATION);

	#### catch - should never get here
	xlog("L_ERROR","Can't deal with number $rU from $si:$sp - sending error");
	sl_send_reply("501","Fuck off");
    exit;
}

# Create Contact Record
route[CONTACT] {
	if ($(ct{tobody.user})!=$null) {
		$var(ctuser) = $(ct{tobody.user});
		$var(cthost) = $si;
		$var(ctport) = $sp;
		xlog("L_INFO","Contact: <sip:$var(ctuser)@$var(cthost):$var(ctport)");
		#remove_hf("Contact");
		#insert_hf("Contact: <sip:$var(ctuser)@EXTERNAL_NAME:$var(ctport)\r\n");
	}
	return ;
}


# set applicable flags
route[FLAGS] {
	# Check the type of UAC
	if ($pr == "ws" || $pr == "wss") {
		setflag(FLT_SRC_WS);
	}
	else {
		setflag(FLT_SRC_SIP);
	}

	if (isflagset(FLT_SRC_WS)) {
		setbflag(FLB_WS_DEVICE);
	}

#!ifdef WITH_MSTEAMS
	# Source is MSTEAMS
	if ($hdr(User-Agent) =~ "Microsoft.PSTNHub") {
		setflag(FLB_SRC_MSTEAMS);
	}
	xlog("=======> User-Agent = $hdr(User-Agent)");
	
	# Source is MSTEAMS - but call is onhold
	if (is_method("INVITE") && $hdr(User-Agent) =~ "Microsoft.PSTNHub" && $avp(sdp_media_direction) == "inactive") {
		setflag(FLB_SRC_MSTEAMS_ONHOLD);
    }
	
	# Destination is Microsoft Teams
	if ($rd =~ "pstnhub.microsoft.com") {
		setflag(FLB_DST_MSTEAMS);
	}

	# Source is Microsoft Teams
	if ($su =~ "sip.pstnhub.microsoft.com" | $su =~ "sip2.pstnhub.microsoft.com" | $su =~ "sip3.pstnhub.microsoft.com") {
		setflag(FLB_SRC_MSTEAMS);
	}
#!endif

	## Transaction Flags
	xlog("****=== FLAG INFO ===***");
	if (isflagset(FLT_SRC_WS)) {
		xlog("****Source: Websockets");
	}
	if (isflagset(FLT_SRC_SIP)) {
		xlog("****Source: Native SIP");
	}

	## Branch Flags
	if (isbflagset(FLB_SRC_MSTEAMS)) {
		xlog("****Source: Microsoft Teams");
	}
	if (isbflagset(FLB_SRC_MSTEAMS_ONHOLD)) {
		xlog("****Source: Microsoft Teams (ON-HOLD)");
	}
	if (isbflagset(FLB_DST_MSTEAMS)) {
		xlog("****Destination: Microsoft Teams");
	} else {
		xlog("****Destination: SIP");
	}
	
	# see if we can get rid of this
	# use RTPE for WS and MSTEAMS
	#if (isbflagset(FLB_WS_DEVICE) || isbflagset(FLB_SRC_MSTEAMS) || isbflagset(FLB_SRC_MSTEAMS_ONHOLD) || isbflagset(FLB_DST_MSTEAMS)) {
    #    # WebRTC destination or MSTEAMS source
    #    setflag(FLT_USE_RTPE);
    #}
}
######################################################################
# Notify someone that a emergency number has been dialed - via uac
######################################################################
route[ENOTIFY] {
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
	$uac_req(ruri)="sip:TRUNK_HOSTP:TRUNK_PORT";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Emergency Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
    $uac_req(evroute)=1;
	
	// Permit authentication
	t_on_failure("MANAGE_FAILURE");

    // Send UAC Request
	xlog("L_INFO", "Sending $uac_req(method) request to $uac_req(ruri)");
	uac_req_send();
	
    return ;
}

route[EHANDLING] {
	# Australian Emergency Numbers (Victoria)
	# 000 (Emergency), 112 (Emergency)
	# Others: 132 500 (SES), 131 444 (Police Assistance) 131 114 (Lifeline)

    if($tU == "000" or $tU == "+61000" or $tU == "112" or $tU == "999000") {
        xlog("L_CRITICAL","Emergency call ($tU) from $fU [$rm]");
		route(ENOTIFY);
		## if it s our test number, don't route, just notify is enough
		if ($tU != "999000") {
			$ru = "sip:" + "+61000" + "@" + "EXTERNAL_NAME";
			$var(disgroup) = 99;
			route(DISPATCH);
		} else {
			sl_send_reply("403", "Test Success for Emergency Call");
		}
		exit;
    }
    return ;
}

## Private Routing (Internal)
route[PABX] {

	# testing
	route(CONTACT);
	
    if (($tU=~"^\+61395107066|\b(2[0-9][0-9]{1})\b")) {

        ## Albert Park Extension
        xlog("L_INFO","Routing call $tU to Albert Park");
        # ????
		## $tU = "PABX1_NUMBER";
		$var(disgroup) = 22;
		route(DISPATCH);
		exit;
    };
    if (($tU=~"^\+61359835502|\b(5[0-9][0-9]{1})\b")) {
		## Somers Camp Extension
        xlog("L_INFO","Routing call $tU to Somers");
        # ???
		## $ru= "PABX2_NUMBER";
		$var(disgroup) = 55;
		route(DISPATCH);
		exit;
    };
    xlog("L_INFO","Call to $tU cannot be an internal call");
}

## MS Team Routing
route[TEAMS] {
#!ifdef WITH_MSTEAMS
    ## Send to VM: "sip:user@yourdomain.com;opaque=app:voicemail"
    # MSTeam needs the correct contact header, other you'll get forbidden
	route(CONTACT);
	$var(disgroup) = 44;
	route(DISPATCH);
#!endif
	return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
	if (nat_uac_test("19")) {
		# new
		force_rport();
		# xlog("L_INFO","***NAT**** detected for $rm ($fu ($si:$sp) to $tu)");
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if(is_first_hop()) {
				set_contact_alias();
			}
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# Handle SIP registrations
route[REGISTRAR] {
	if (!is_method("REGISTER")) return;

	if(isflagset(FLT_NATS)) {
		setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
		# do SIP NAT pinging
		setbflag(FLB_NATSIPPING);
#!endif
	}
	if (!save("location")) {
		sl_reply_error();
	}
	exit;
}

# IP authorization and user authentication
route[AUTH] {
#!ifdef WITH_AUTH
#!ifdef WITH_IPAUTH
	if((!is_method("REGISTER")) && allow_source_address()) {
		# source IP allowed
		return;
	}
#!endif

	if (is_method("REGISTER") || from_uri==myself) {
		# authenticate requests
		if (!auth_check("$fd", "subscriber", "1")) {
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();
	}
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}

#!else
	# authentication not enabled - do not relay at all to foreign networks
	if(from_uri!=myself && uri!=myself) {
		xlog("L_ERROR","Authentication not enabled - so not relaying");
		sl_send_reply("403","Not relaying");
		# sl_send_reply("503", "Service not available");
		exit;
	}

#!endif
	return;
}

route[SIPOUT] {
    if (uri==myself) return ;
    append_hf("P-hint: outbound\r\n");
    route(RELAY);
    exit;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

	route(RTPOFFER);

	if (is_method("BYE")) {
        append_hf("X-RTP-Statistics: $rtpstat\r\n");
	}

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
	}

	if(isbflagset(FLB_NATB)) {
		# no connect message in a dialog involving NAT traversal
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}
#!endif
	return;

	# transcode everything to Opus
	$var(rtpengine_codec) = "mask-all transcode-opus";
	
	# transcode everything to G729
	$var(rtpengine_codec) = "codec-strip=all codec-offer=G729 codec-offer=telephone-event";

	$var(rtpengine_flags) = "ICE=force-relay DTLS=passive";
	
	# UDP
	$var(rtpengine_conn) = "UDP/RTP/AVP";

	# TCP
	$var(rtpengine_conn) = "TCP/RTP/AVP";
	
	# nat_uac_test("8"): The SDP is searched for occurrence of RFC1918 (Private Address Space) or RFC6598 (Carrier Grade NAT) addresses
	#if(nat_uac_test("8")) {
	#	rtpengine_manage("$var(rtpengine_conn)" + "replace-origin replace-session-connection ICE=remove "    + "$var(rtpengine_codec)");
	#} else {
	#	rtpengine_manage("$var(rtpengine_conn)" + "trust-address replace-origin replace-session-connection " + "$var(rtpengine_codec)");
	#}
		
	# replace-origin - flags that IP from the origin description (o=) should be also changed.
	# trust-address - flags that IP address in SDP should be trusted. ignores address in the SDP and uses source address of the SIP message as media address which is passed to the RTP proxy.
	# replace-session-connection - flags to change the session-level SDP connection (c=) IP if media description also includes connection information.
	# ICE=... - controls the RTP proxy's behaviou
	#     “force” - discard any ICE attributes already present in the SDP body and then generate and insert new ICE data, leaving itself as the only ICE candidates; “force-relay” - discard any “relay” type ICE attributes already present in the SDP body and then generate and insert itself as the only ICE “relay” candidates;
	#     “remove” instructs the RTP proxy to discard any ICE attributes and not insert any new ones into the SDP.
	#     The default (if no “ICE=...” is given at all), new ICE data will only be generated if no ICE was present in the SDP originally; otherwise the RTP proxy will only insert itself as additional ICE candidate. Other SDP substitutions (c=, m=, etc) are unaffected by this flag.
	#
	#

	# Calls to 3CX neeeds to be unencrypted (TCP/RTP/AVP) (label=3CX)
	# Calls to Trunk neeeds to be unencrypted (UDP/RTP/AVP) (label=TRUNK)
	# Calls to MSTEAMS neeeds to be encrypted (RTP/SAVP) (label=MSTEAMS)

	# WEBRTC Bridge RTP/AVP <-> RTP/SAVPF
	
	# strip all codecx and rewrite with G729
	# example: codec-strip=all codec-offer=G729 codec-offer=telephone-event
	# G.729 when bandwidth must be conserved. 
		
	# any sdp changes - 

	# to instruct rtpengine to translate the SDP to plain RTP when sending to Asterisk.
	# The appropriate flag to use in this case would be `RTP/AVP`

	# RTP/AVP - Real-time Transport Protocol / Audio Video Profile TCP/RTP/AVP
	# RTP/AVPF - Extended RTP Profile for RTCP-based Feedback (Audio-Visual Profile with Feedback)
	# RTP/SAVP - Real-time Transport Protocol / Secure Audio Video Profile (over DTLS) DCCP/TLS/RTP/SAVP
	# RTP/SAVPF - Extended Secure RTP Profile for RTCP-based Feedback (over DTLS) DCCP/TLS/RTP/SAVPF
	
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;

	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		# test
		###if(is_method("INVITE|UPDATE") && sdp_content() && nat_uac_test("18"))
        ###     rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=internal direction=external");
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("ACK") ) {
			# ACK is forwarded statelessly
			route(NATMANAGE);
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		### route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			route(RELAY);
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}

route[E164] {
	# 1 (true) for E164 numbers
	# -1 (false) for everything else

	# checking using regex
	if (($rU =~ "^\+[0-9]+$")) {
		return 1;
	}

	# checking using siputils
	if (is_tel_number("$rU")) { 
		return 1;
	}	
	return -1;
}

route[TRUNK] {
#!ifdef WITH_TRUNK
	# trunk calls need to be in E.164 format (+country etc...)
	
	# we only accept Australian numbers
	if (!($tU =~ "^\+61")) {
		xlog("L_ERROR", "TRUNK: $tU is not an Australian number, reject - $rm from $fu to $du (IP:$si:$sp)\n");
		sl_send_reply("403", "International calls ($$) are not allowed");
		exit;
	}

	# sorry no Australian premium services
	if (($tU =~ "^\+61190")) {
		xlog("L_ERROR", "TRUNK: $tU is a premium number, reject - $rm from $fu to $du (IP:$si:$sp)\n");
		sl_send_reply("403", "Premium calls ($$) are not allowed");
		exit;
	}

	$var(disgroup) = 99;
	route(CONTACT);
	route(DISPATCH);
#!endif
	exit;
}

######################################################################
# Send a SIP messages (like an SMS) -  via uac module
######################################################################
route["SEND_MESSAGE"] {
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
    $uac_req(ruri)="sip:TRUNK_HOSTP:TRUNK_PORT";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Message Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    // $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
	$uac_req(body)="A Message";
    $uac_req(evroute)=1;

	// Permit authentication
	t_on_failure("MANAGE_FAILURE");

    // Send UAC Request
    xlog("L_INFO", "Sending $uac_req(method) request to $uac_req(ruri)");
	uac_req_send();

	return ;
}

event_route[uac:reply] {
    xlog("received UAC reply code is: $uac_req(evcode)\n");
}

#!ifdef WITH_DISPATCHER
route[DISPATCH] {
	# destination sorted by priority attribute value (serial forking ordered by priority).
	# ds_select_domain vs ds_select_dst 
	# ds_select_dst (updates $du) vs ds_domain_dst (updates $ru)
	# $du - reference to destination uri, $ru - reference to request's URI (address in the first line of a SIP request)
    if(!ds_select_domain($var(disgroup), "8")) {
        send_reply("404", "No destination");
        exit;
    }
    # Add Route Header
	route(CONTACT);
	xlog("L_INFO","DISPATCH ===> Sending call $rU [$rm] ($fu ($si:$sp)");
			
    route(RELAY);
    exit;
}

event_route[dispatcher:dst-up] {
    xlog("L_INFO", "Dispatcher destination <$ru> is UP\n");
}
event_route[dispatcher:dst-down] {
    xlog("L_ERROR", "Dispatcher destination <$ru> is DOWN\n");
}
#!endif

# Wrapper for relaying requests
route[RELAY] {
#!ifdef WITH_NAT
	handle_ruri_alias();
	switch ($rc) {
        case -1:
            xlog("L_ERR", "NAT (ruri_alias) Failed to handle alias of R-URI $ru\n");
            send_reply("400", "Bad request");
            exit;
        case 1:
            # xlog("L_INFO", "NAT (ruri_alias) Routing in-dialog $rm from $fu to $du\n");
            break;
        case 2:
            # xlog("L_INFO", "NAT (ruri_alias) Routing in-dialog $rm from $fu to $ru\n");
            break;
    };
#!endif
	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}
	xlog("L_INFO", "Attempting relaying for $ru\n");
	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
#!ifdef WITH_NAT
	route(NATMANAGE);
#!endif
}

# Manage route failures with MS Teams and others
failure_route[MANAGE_FAILURE] {

    if (t_is_canceled()) exit;

    # info
    xlog("I_INFO","****DESTINATION FAILURE***** with $T(reply_reason)[$T(reply_code)]");

#!ifdef WITH_TRUNK
    # need to authenticate trunk TODO: check destination IP addresss
    if(t_check_status("401|407")) {
        xlog("L_INFO", "Trying to Authenticate to Trunk $ru with TRUNK_USER...");
        $avp(auser) = "TRUNK_USER";
        $avp(apass) = "TRUNK_PASSWORD";
        uac_auth();
        t_relay();
        exit;
    }
#!endif

#!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
#!endif

#!ifdef WITH_BLOCK401407
    # block call redirect based on 401, 407 replies.
    if (t_check_status("401|407")) {
        t_reply("404","Not found");
        exit;
    }
#!endif
	exit;
}

route[BLOCKIP] {
#!ifdef WITH_APIBAN
	if (src_ip!=myself) {
		xlog("L_INFO","[R-BLOCKIP:$ci]: blocking $rm from $fu (IP:$si:$sp)\n");
		$sht(ipban=>$si) = 1;
	}
#!endif
	return;
}

#!ifdef WITH_SIPDEBUG
onsend_route {
	xlog("L_INFO","[ONSEND_ROUTE] SIP DEBUG: \n$snd(buf)\n");
}

onreply_route {
    xlog("L_INFO","[ONREPLY_ROUTE] SIP DEBUG: \n$snd(buf)\n");
}
#!endif

# AAAAA
reply_route {
	route(RTPANSWER);	
}
# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
	xdbg("incoming ROUTE reply\n");
#!ifdef WITH_NAT
	if(status=~"[25][0-9][0-9]") {
		route(NATMANAGE);
	}
#!endif
}

#!ifdef WITH_MSTEAMS
# stateful logic - this can be permanent - does no harm
event_route[tm:local-request] {
    if(is_method("OPTIONS") && $ru =~ "pstnhub.microsoft.com") {
		## Keepalive need Contact header for Microsoft Teams
		append_hf("Contact: <sip:EXTERNAL_NAME:5061;transport=tls>\r\n");
#!ifdef	 WITH_DEBUG
    	xlog("L_INFO", "Responded to OPTIONS keepalive from Microsoft Teams\n");
#!endif
    }
}
#!endif
