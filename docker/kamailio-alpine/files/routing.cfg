
####### Routing Logic ########

onreply_route {
        xlog("We received a reply from $si\n");
}

/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

#!ifdef WITH_EXEC
	exec_msg("/etc/kamailio/execshow.sh >>/tmp/aw123.out");
#!endif

	xlog("L_INFO","=UNFILTERED=>: $rm ($fu ($si:$sp) to $tu, $ci)\n");
	
	route(FIRST);
	route(INFO);

	route(EMERGECY_HANDLING);
	
	# per request initial checks
	route(REQINIT);

#!ifdef WITH_3CX
	# custom routing
	route(3CX);
#!endif
	
	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	# handle requests within SIP dialogs
	#route(WITHINDLG);

	### only initial requests (no To tag)

	# authentication
	route(AUTH);

#!ifndef WITH_MICROSOFT_TEAMS
	# record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");
#!endif

	if (is_method("INVITE|SUBSCRIBE")) {
#!ifdef WITH_MICROSOFT_TEAMS
		## record_route(); - default, to
        record_route_preset("sbc.lordsomerscamp.org.au:5061;transport=tls", "20.190.118.9:5060");
#!else
		record_route();
	};
#!endif

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

	# dispatch requests to foreign domains
	#route(SIPOUT);

	### requests for my local domains

#!ifdef WITH_PRESENCE
	# handle presence related requests
	# we typically dont bother
	route(PRESENCE);
#!endif

	# handle registrations
	### route(REGISTRAR);

	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	# dispatch destinations to PSTN
	#route(PSTN);

	# user location service
	#route(LOCATION);

	# catch - should never get here if number is valid
	sl_send_reply("501","Fuck off");
    exit;
}

route[FIRST] {
    # Check for shutdown mode:
    if ($sel(cfg_get.system.shutdownmode) > 0) {
		xlog("L_WARN", "Shuting down so ignoring $si\n");
        send_reply("503", "Server shutting down");
        exit;
   	}
#!ifdef WITH_WEBSOCKETS
	# Make sure WS/WSS only come on dedicated ports
	if ((($Rp == WS_PORT || $Rp == WSS_PORT) && !(proto == WS || proto == WSS)) ) {
		xlog("L_WARN", "WSS/WS request received on wrong TCP port $Rp - ignoring");
		sl_send_reply("403", "Forbidden");
		exit;
	}
#!endif
    if (is_method("INVITE|REGISTER")) {
        # scanner - IP address in UA
        if($sel(contact.uri.host) =~ "^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$") {
            xlog("L_INFO","$si is using IP addressess instead of DNS - ignoring");
            exit;
        }
        # SQL Injection
        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
            xlog("L_INFO","$si:$sp is trying to do a sql injection attack with $au - ignoring");
            exit;
        }
        # Spoofing Attack
        if($(hdr(Record-Route)[0]{nameaddr.uri}) != $si and $(hdr(Record-Route)[0]{nameaddr.uri}) != $null) {
            xlog("L_INFO","Spoofing attack detected from $si - ignoring");
            exit;
        }
    }
	# check if known SIP scanner
	if($ua =~ "(Cisco-SIPGateway|Intraswitch|friendly-scanner|sipvicious|sipcli|sip-scan|sipsak|sundayddr|iWar|CSipSimple|SIVuS|Gulp|sipv|smap|friendly-request|VaxIPUserAgent|siparmyknife|Test Agent)") {
        xlog("L_ERROR","Known SIP Scanner [$ua] trying to call $rU - ignoring");
		# optional send Ok - can make the scammers stop sooner
		sl_send_reply("200", "OK");
        exit;
    }
    
	# check if known User Agent - ignore otherwise
	# need to add Microsoft and need NUL for trunks to connect
	if !($ua =~ "(3CX|baresip|Linphone)" || $ua==$null) {
        xlog("L_ERROR","Unknown User Agent [$ua] trying to call $rU - ignoring\n");
		# optional send Ok - can make the scammers stop sooner
		sl_send_reply("200", "OK");
        exit;
    }
    
	# too many hops
	if (!mf_process_maxfwd_header("10")) {
		xlog("L_ERROR","Too many hops from $si:$sp - ignoring\n");
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	# SIP message too big
	if (msg:len>2048) {
		xlog("L_ERROR","SIP Message too big from $si:$sp - ignoring\n");
		sl_send_reply("413","Message too large");
		exit;
	}

	# Phone number too long
	if ($(rU{s.len}) > 15 {
		xlog("L_ERROR", "Phone number is too long from $si:$sp with $rU - ignoring");
		sl_send_reply("413","Phone number too long");
		exit;
	}
	
	# process keep alives - but only ones sent to here
	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		xlog("L_INFO","Sending Keepalive $si:$sp - ignoring\n");
		sl_send_reply("200","Keepalive");
		exit;
	}

	# malformed SIP messages
	if(!sanity_check("1511", "7")) {
		xlog("L_ERROR","Malformed SIP message from $si:$sp - ignoring\n");
		# quietly ignore
		exit;
	}
	return;
}

route[INFO] {
#!ifdef WITH_GEOIP
    if(geoip2_match("$si", "src")){
 		##xlog("L_INFO","Packet recieved from IP $si");
		##xlog("L_INFO","Country is: $gip2(src=>cc)\n");
		##xlog("L_INFO","City is:  $gip2(src=>city)");
		##xlog("L_INFO","ZIP is:  $gip2(src=>zip)");
		##xlog("L_INFO","Regc is:  $gip2(src=>regc)");
		##xlog("L_INFO","Regn is:  $gip2(src=>regn)");
		##xlog("L_INFO","Metro Code is:  $gip2(src=>metro)");
        if($gip2(src=>cc)==""){
            xlog("L_INFO","Cannot determine geoip ip for [$si] - ignoring");
            exit;
        }
        ## Microsoft sip[1|2].pstnhub.microsoft.com are located in
        ## Singapore (SG), USA (US) and Netherlands (NL)
	    if($gip2(src=>cc)=~"AU|US|NL|SG"){
            ## Pretty format
            ## xlog("L_INFO","processing: $gip2(src=>cc):$pr:$si:$sp[$rm]($fu) [$ua]\n");
			## xlog("L_INFO","Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci] [$ua]\n");
			xlog("L_INFO","=FILTERED=>: $rm ($fu ($si:$sp) to $tu, $ci)\n");
			## xnotice("[$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci]\n");
        } else {
            xlog("L_INFO","Traffic [$si] is not from AU/US/NL/SG, its from $gip2(src=>cc) so - ignoring");
            exit;
        }
    }
#!endif
#!ifdef WITH_SDPOPS
	if(sdp_content()) {
		# 1 = level 
    	sdp_print("1");
	};
#!endif
	return;
}

# Per SIP request initial checks
route[REQINIT] {
	# no connect for sending replies
	set_reply_no_connect();
	# enforce symmetric signaling
	# - send back replies to the source address of request
	force_rport();

#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("17895","7")) {
		xlog("Malformed SIP request from $si:$sp\n");
		exit;
	}
}

route[FORWARD] {
	# +123456789
	# now check if it really is a PSTN destination which should be handled
	# by our gateway; if not, and the request is an invitation, drop it --
	# we cannot terminate it in PSTN; relay non-INVITE requests -- it may
	# be for example BYEs sent by gateway to call originator
	if (!uri=~"sip:\+?[0-9]+@.*") {
		if (method=="INVITE") {
			sl_send_reply("403", "Call cannot be served here");
		} else {
			xlog("L_ERROR","Forwarding from $si:$sp\n");
			forward(uri:host, uri:port);
		};
		break;
	}; 
	# forward the request now
	if (!t_relay()) {
		sl_reply_error(); 
		break; 
	};
	return ;
}

######################################################################
# Enum first, then whatever the PSTN gateway is
######################################################################
route[PSTN_HANDLING] {
#!ifdef WITH_ENUM
	# First, we translate "tel:"-URI's to SIP-URI's:
	# $ru:           tel:+(34)-999-888-777
	# $fu:           sip:test@foo.com
	# becomes $ru:   sip:+34999888777@foo.com;user=phone
	if (!tel2sip("$ru", "$fd", "$ru")) {
		xlog("L_WARN","Failed to convert $ru to a sip:-URI - M=$rm R=$ru F=$fu T=$tu IP=$si:$sp ID=$ci\n\n");
        return ;
	}
    if ($rU =~ "\+[0-9]+") {
        # Now let's check, if the number can be found in ENUM:
		if(!enum_query()) {
			# ENUM failed, send it to the PSTN-Gateway:
            return ;
        }
    }
#!endif
	return ;
}

route[EMERGECY_HANDLING] {
	# Australian Emergency Numbers (Victoria)
	# 000 (Emergency), 112 (Emergency) , 132 500 (SES), 131 444 (Police Assistance)
	# 131 114 (Lifeline)

    if(is_method("INVITE") && ($rU == "000" or $tU == "112" or $tU == "31" or $tU == "999000")){
        #Matches any INVITEs with the Request URI to Address as 000, 112 or 116
        xlog("L_CRITICAL","Emergency call from $fU to $rU (Emergency number) CSeq is $cs ");
        ###route("EMERGENCY_NOTIFY");
		route(CAMP);
        #You obviously would want this to route to an emergency services destination...
        sl_reply("200", "ok");
        exit;
    }
    return ;
}

route[PABX] {
    if (uri=~"sip:2[0-9]{1}@.EXTERNAL_NAME") {
		## Albert Park Extension
		xlog("L_INFO","Routing extension 2[0-9] to Albert Park");
		## route(ALBERT);
	};
	if (uri=~"sip:3[0-9]{1}@.EXTERNAL_NAME") {
		## Albert Park Extension
		xlog("L_INFO","Routing extension 3[0-9] to Somers");
		route(CAMP);
	};
	# Cant be internal
	return ;
}

######################################################################
# Albert Park Routing - Extensions 2*s
######################################################################
route[PABX1] {
    ##rewritehostport("1.2.3.4",5070);
	route(RELAY);
	return ;
}

######################################################################
# Somers Camp Routing - Extensions 3*s
######################################################################
route[PABX2] {
    rewritehostport("camp.lordsomerscamp.org.au:5070");
	route(RELAY);
	exit ;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
	if (nat_uac_test("19")) {
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if(is_first_hop()) {
				set_contact_alias();
			}
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}

route["REGISTAR"] {
    if (!is_method("REGISTER")) return;
#!ifdef WITH_IPAUTH
	if (allow_register("register.allow", "register.deny")) {
#!endif
   		if (!save("location")) {
	   		sl_reply_error();
    	}
    	exit;
#!ifdef WITH_IPAUTH
    } else {
	    sl_send_reply("403", "Forbidden");
    };
#!endif
}

#!ifdef WITH_MICROSOFT_TEAMS
# stateful logic
event_route[tm:local-request] {
    if(is_method("OPTIONS") && $ru =~ "pstnhub.microsoft.com") {
    	append_hf("Contact: <sip:sbc.lordsomerscamp.org.au:5061;transport=tls>\r\n");
    	xlog("L_INFO", "Responded to keepalive from Microsoft Teams\n");
    }
}
#!endif

# IP authorization and user authentication
route[AUTH] {
#!ifdef WITH_AUTH
#!ifdef WITH_IPAUTH
	if((!is_method("REGISTER")) && allow_source_address()) {
		# source IP is not allowed
		return;
	}
#!endif
	if (is_method("REGISTER") || from_uri==myself) {
		# authenticate requests
		# change 1 to 0 so extension / auth_name can be different
		# $fd (from domain)
        if (!auth_check("$fd", "subscriber", "0")) {
			xlog("L_INFO", "auth_check failed - challenging $au in $fd");
			auth_challenge("$fd", "0");
		}
		xlog("L_INFO", "Auth Challenge success for $au in $fd ");
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			# so next inline won't see them
			consume_credentials();
	}
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}
    return;
#!else
	xlog("L_ERROR", "Authenication is not enabled so we are not doing anything for anyone!!!");
    sl_send_reply("403","Not relaying");
	exit;
#!endif
}

## something wrong
route[SOMERS_PSTN] {
	# Only if the AVP 'gw_ip' is set and the request URI contains
	# only a number we consider sending this to the PSTN GW.
	# Only users from a local domain are permitted to make calls.
	# Additionally you might want to check the acl AVP to verify
	# that the user is allowed to make such expensives calls.
#	if ($f.did != "" && $gw_ip != "" &&
#		uri=~"sips?:\+?[0-9]{3,18}@.*") {
		# probably you need to convert the number in the request
		# URI according to the requirements of your gateway here
		# if an AVP 'asserted_id' is set we insert an RPID header
#		if ($asserted_id != "") {
#			xlset_attr("$rpidheader", "<sip:%$asserted_id@%@ruri.host>;screen=yes");
#			replace_attr_hf("Remote-Party-ID", "$rpidheader");
#		}
		# just replace the domain part of the RURI with the
		# value from the AVP and send it out
#		attr2uri("$gw_ip", "domain");
#		route(FORWARD);
#	}
    return ;
}

route[SIPOUT] {
    if (uri==myself) return ;
    append_hf("P-hint: outbound\r\n");
    route(RELAY);
    exit;
}

#!ifdef WITH_WEBSOCKET
event_route[xhttp:request] {
	set_reply_close();
	set_reply_no_connect();
	
	if ($Rp != MY_WS_PORT
#!ifdef WITH_TLS
	    && $Rp != MY_WSS_PORT
#!endif
	) {
		xlog("L_WARN", "HTTP request received on $Rp\n");
		xhttp_reply("403", "Forbidden", "", "");
		exit;
	}

	if ($hdr(Upgrade)=~"websocket"
			&&  in_list("Upgrade", $hdr(Connection), ",")
			&& $rm=~"GET") {

		# Validate Host - make sure the client is using the correct
		# alias for WebSockets
		if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
			xlog("L_WARN", "Bad host $hdr(Host)\n");
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}

#!ifdef WEBSOCKET_WEBSERVER
		# Validate Origin - make sure the client is from the authorised website
		if ($hdr(Origin) != "http://"+WEBSOCKET_WEBSERVER
#!ifdef WITH_TLS
		  && $hdr(Origin) != "https://"+WEBSOCKET_WEBSERVER
#!endif
		) {
			xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}
#!endif
		# ws_handle_handshake() exits (no further configuration file
		# processing of the request) when complete.
		if (ws_handle_handshake()) {
			# Optional... cache some information about the
			# successful connection
			exit;
		}
	}

	# xhttp_reply("200", "OK", "text/html", "<html><body>Wrong URL $hu</body></html>");
	xhttp_reply("404", "Not Found", "", "");
}

event_route[websocket:closed] {
	xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}
#!endif

# Presence server processing
route[PRESENCE] {
	if(!is_method("PUBLISH|SUBSCRIBE")) return;

	if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
#!ifdef WITH_VOICEMAIL
		route(TOVOICEMAIL);
#!endif
		# returns here if no voicemail server is configured
		sl_send_reply("404", "No voicemail service");
		exit;
	}

#!ifdef WITH_PRESENCE
#!ifdef WITH_MSGREBUILD
	# apply changes in case the request headers or body were modified
	msg_apply_changes();
#!endif
	if (!t_newtran()) {
		sl_reply_error();
		exit;
	}

	if(is_method("PUBLISH")) {
		handle_publish();
		t_release();
	} else if(is_method("SUBSCRIBE")) {
		handle_subscribe();
		t_release();
	}
	exit;
#!endif

	# if presence enabled, this part will not be executed
	if (is_method("PUBLISH") || $rU==$null) {
		sl_send_reply("404", "Not here");
		exit;
	}
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}
# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;

	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("ACK") ) {
			# ACK is forwarded statelessly
			route(NATMANAGE);
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			route(RELAY);
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}

#!ifdef WITH_TRUNK
#!ifdef WITH_UAC
route[TRUNK] {
	if (is_method("INVITE")) {
		# check if US/AUS number format (no international) - 411 (US), 1223 (Aus) is directory assitance
        if($ru=~"[2-9][0-9]{9}|[0][2-478][0-9]{8}|411|1223") {
            $du = "sip:TRUNK_HOSTP:TRUNK_PORT";
            xlog("I_INFO","=======> Sending call $rU to the trunk $du");
			t_on_failure("TRUNKAUTH");
            t_relay();
            exit;
		}
    }
}

failure_route[TRUNKFAIL] {
    
	if (t_is_canceled()) {
        exit;
    }

	# info
	xlog("I_INFO","****TRUNKFAIL***** with $T(reply_reason)[$T(reply_code)]");
	
	# 403 means we got the number format wrong 
	if(t_check_status("403")) {
		xlog("L_INFO", "Trunk replied with forbidden (number format/maybe inactive)" );
		exit;
    }

	# need to authenticate trunk
	if(t_check_status("401|407")) {
		xlog("L_INFO", "Trunk needs authentication....trying...");
		$avp(auser) = "TRUNK_USER";
        $avp(apass) = "TRUNK_PASSWORD";
        uac_auth();
		t_relay();
        exit;
    } 
	#else {
	#	$du = "sip:TRUNKS_HOST:TRUNK_PORT";
	#	xlog("I_INFO","Sending call $rU to secondary SIP trunk $du");
	#	t_relay();
	#	exit;
	# }
}

######################################################################
# Notify someone that a emergency number has been dialed
######################################################################
route["EMERGENCY_NOTIFY"] {
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
    $uac_req(ruri)="sip:10.0.1.5:5060";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Emergency Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
    $uac_req(evroute)=1;
    uac_req_send();
    return ;
}

######################################################################
# Send a messages (SMS)
######################################################################
route["SEND_MESSAGE"] {
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
    $uac_req(ruri)="sip:10.0.1.5:5060";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Emergency Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
    $uac_req(evroute)=1;
    uac_req_send();
    return ;
}

######################################################################
# Send an outbound call via trunk
######################################################################
route["TRUNK_CALL"] {
    xlog("Emergency Notify Route");
    $uac_req(method)="MESSAGE";
    $uac_req(ruri)="sip:10.0.1.5:5060";
    $uac_req(furi)="sip:Emergency Alert";
    $uac_req(turi)="sip:thisphone";
    $uac_req(callid)=$(mb{s.md5});
    $uac_req(hdrs)="Subject: Somers Emergency Alert\r\n";
    $uac_req(hdrs)=$uac_req(hdrs) + "Content-Type: text/plain\r\n";
    $uac_req(body)="Emergency call from " + $fU + " on IP Address " + $si + " to " + $rU + " (Emergency Number)";
    $uac_req(evroute)=1;
    uac_req_send();
    return ;
}

event_route[uac:reply] {
    xlog("received reply code is: $uac_req(evcode)\n");
}
#!endif 
#!endif

route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

#!ifdef WITH_RTPENGINE
	if(nat_uac_test("8")) {
		rtpengine_manage("replace-origin replace-session-connection");
	} else {
		rtpengine_manage("trust-address replace-origin replace-session-connection");
	}
#!else
	if(nat_uac_test("8")) {
		rtpproxy_manage("co");
	} else {
		rtpproxy_manage("cor");
	}
#!endif

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
	}

	if(isbflagset(FLB_NATB)) {
		# no connect message in a dialog involving NAT traversal
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}
#!endif
	return;
}


# Wrapper for relaying requests
route[RELAY] {
	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	if(status=~"[12][0-9][0-9]") {
		route(NATMANAGE);
	}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	route(NATMANAGE);

	if (t_is_canceled()) exit;

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_BLOCK401407
	# block call redirect based on 401, 407 replies.
	if (t_check_status("401|407")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_VOICEMAIL
	# serial forking
	# - route to voicemail on busy or no answer (timeout)
	if (t_check_status("486|408")) {
		$du = $null;
		route(TOVOICEMAIL);
		exit;
	}
#!endif
}